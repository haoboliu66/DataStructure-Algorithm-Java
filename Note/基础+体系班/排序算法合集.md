# Merge Sort

T(N) = 2*T(N/2) + O(N^1)

根据master可知时间复杂度为O(N*logN)

merge过程需要辅助数组，所以额外空间复杂度为O(N)

归并排序的实质是把比较行为变成了有序信息并传递，比O(N^2)的排序快



Recursive:

f(arr, L, R) 让arr从L...R有序

f(arr, L, M) 让左半部分有序

f(arr, M+1, R) 让右半部分有

merge操作让整体有序



Iterative:

[2, 3, 1, 4, 6, 0, 7, 5]

设置step, 初始为1

先处理2,3, 再处理1,4 依次进行

然后step 乘以 2

处理 2,3,1,4的范围 和 6,0,7,5的范围

一直进行下去, 直到step超过数组长度N

step每次乘以2, step的变化是logN, 每次调整step后遍历一遍, 所以复杂度是O(N*logN)



Takeaway:

手写实现Recursive和Iterative的Mergesort



## 1.数组小和问题

在一个数组中，一个数左边比它小的数的总和，叫数的小和，所有数的小和累加起来，叫数组小和。求数组小和。

例子： [1,3,4,2,5] 

1左边比1小的数：没有

3左边比3小的数：1

4左边比4小的数：1、3

2左边比2小的数：1

5左边比5小的数：1、3、4、 2

所以数组的小和为1+1+3+1+1+3+4+2=16 



例子:

[4,2,1,3,0,6,3,9]

求每个数 右边范围内 有几个数比它大

在merge的过程中求解, 相等的话, 先拷贝右组的





## 2.逆序对问题 - Easy

> 493.Reverse Pairs

在一个数组中, 任何一个前面的数a，和任何一个后面的数b, 如果(a,b)是降序的，就称为逆序对

返回数组中所有的逆序对

**找到一个数的右边有几个比他小的**

merge过程从右往左进行

相等的话, 先拷贝右组的





## 3.Reverse Pairs - Hard

> 493.Reverse Pairs

在一个数组中, 对于每个数num，求有多少个后面的数 * 2 依然 < num，求总个数

比如：[3,1,7,0,2]

3的后面有：1，0

1的后面有：0

7的后面有：0，2

0的后面没有

2的后面没有

所以总共有5个



merge方法中从左到右先计算有多少个满足要求的逆序对, 

**考察左组的每一个数, 在右组中可以划过几个数**

然后再单独进行正常的merge操作





## 4.Count of Range Sum

> 327.Count of Range Sum

x  =>  x-upper, x-lower

 假设0...i整体累加和是x, 求必须以x结尾的子数组, 有多少个累加和在[lower, upper]范围上

等同于求, i之前的所有前缀和, 有多少个在 [x-upper, x-lower]范围上



两个指标不回退



对于每一个右组的数, 计算他需要的指标, 然后在左组中找到符合指标的数有几个, 但是这种类似merge的操作会忽略一种情况:

0...i 这个范围, 即左侧一个数也不考虑的情况, 0...i这个子数组此时没有被考虑, 所以这种情况单独在数组拆分的base case里进行计算





# Quick Sort

## 荷兰国旗问题

给定一个数字x, 在arr中把小于x的放左边, 等于x的放中间, 大于x的放右边



## 快排1.0

选出R位置的数字x

[.............x] => [<=x | x | >x]

x找到了自己的正确位置X, 向两侧递归继续



## 快排2.0

选出R位置的数字x

[.............x] => [<x | x | >x]

等于区不用再动了, 向两侧递归

快排2.0一次搞定一批数字, 快排1.0一次搞定一个数字



## 快排3.0 (随机快排)

考虑到最差情况 eg.  [1,2,3,4,5,6,7],  快排1.0和2.0的复杂度都是O(N^2^)

随机快排和快排2.0的区别在于, 随机选择一个数字(而不是选择R位置的数字)



有随机行为的情况下, 最差情况是概率事件, 所以计算长期期望值, 复杂度收敛到O(N*logN)

快排的额外空间复杂度O(logN)



# Heap & Comparator

堆结构就是用数组实现的完全二叉树结构(Complete Binary Tree)



题目:

已知一个几乎有序的数组。几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离一定不超过k，并且k相对于数组长度来说是比较小的。

请选择一个合适的排序策略，对这个数组进行排序。 



## 堆排序

1，先让整个数组都变成大根堆结构，建立堆的过程: 

  1)从上到下的方法，时间复杂度为O(N*logN) 

  2)从下到上的方法，时间复杂度为O(N) 

2，把堆的最大值和堆末尾的值交换，然后减少堆的大小之后，再去调整堆，一直周而复始，时间复杂度为O(N*logN) 

3，堆的大小减小成0之后，排序完成



## 加强堆

增加反向索引表





# 不基于比较的排序

受限于数据状况



## Counting Sort

假设员工年年龄数组, 排序

设置一个统计数组从1-200, 遍历原数组, 统计每个年龄的个数, 然后遍历统计数组, 把值填回去, 即得到了一个时间复杂度O(N)的排序



计数排序也是桶排序思维的一种, 使用容器进行排序 



## 基数排序

非负, 十进制表示数字







## Bucket Sort











# Trie

设计一种结构。用户可以：

1）void insert(String str)      添加某个字符串，可以重复添加，每次算1个

2）int search(String str)       查询某个字符串在结构中还有几个

3)  void delete(String str)      删掉某个字符串，可以重复删除，每次算1个

4）int prefixNumber(String str) 查询有多少个字符串，是以str做前缀的