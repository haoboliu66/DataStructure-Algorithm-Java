# 随机函数

Math.random => [0, 1) 上的数字等概率返回

[0, x)出现的概率是x,  要把这个概率调整为x^2^, 如何实现?

```java
public static double xToXPower2(){
	return Math.max(Math.random(), Math.random());
}
```

 只有2次都命中我要的范围, 才能保证返回结果是要求的范围





# Master公式

形如:

T(N) = a * T(N/b) + O(N^d)(其中的a、b、d都是常数)

的递归函数，可以直接通过Master公式来确定时间复杂度

如果 log(b,a) < d，复杂度为O(N^d)

如果 log(b,a) > d，复杂度为O(N^log(b,a))

如果 log(b,a) == d，复杂度为O(N^d * logN)



# 二分法

1.有序数组中, 找某个数是否存在

2.有序数组中, 找 >= 某个数最左侧的位置

3.有序数组中, 找 <= 某个数最右侧的位置

4.局部最小值问题



定义局部最小:

1. [0] < [1] or
2. [N] < [N - 1] or
3. [i] < [i - 1] && [i] < [i + 1]

给定无序数组, 任意两个相邻数字不相等, 返回一个局部最小值;

根据趋势, 到一侧进行二分



相似题: 

一个数组, 小于num的都在数组左侧, 大于num的都在数组右侧, 找<num的最后一个位置, 同样可以二分



一种排他性的原则出现, 就可以二分



# 位运算

## 异或运算

异或可以看做无进位相加

1. 0 ^ N = N,   N ^ N = 0 
2. 同样一批数字, 进行异或运算, 不论什么顺序, 结果一样



题目:

1.交换两个数字(不能是同一内存区域才可以用异或)

2.一种数字出现了奇数次, 其他都是偶数次

3.提取出一个int最右侧的1   ===>    01100  ---> 00100

4.两种数字出现了奇数次, 其他都是偶数次

5.统计一个int的2进制一共有多少位1

6.一个数字是不是2的power,  n == n & (~n + 1) 或 n & (n - 1) == 0

- 一个数字只有1个bit是1

7.找到离一个数字最近的2的某次方 => HashMap源码扩容操作





## bitmap

用Set判断数字是否重复, 一个整型进去就占4字节, 太浪费空间



如果要记录0-31范围内的数字是否出现过, 用一个整型的32位即可, 空间是4Byte

数字范围再扩大:

要记录0-1023范围内的数字, 总共1024个数字, 需要一个长度为32的int数组



一个数字 % 64 就等于 一个数字 & 63  (仅在2的次方情况下有效)



## 位运算实现+ - x /







# Trie

把一个字符串数组加成前缀树, 假设字符总数为N, 代价就是O(N)

![](https://raw.githubusercontent.com/haoboliu66/PicBed/master/img/20200918093811.png)



1.统计某个字符串加入过几次: 直接在前缀树上找到, 找到最后一个字符, 查看end值 (哈希表也可以统计)

2.查看加入过的所有字符串有多少个以某字符串做前缀, 在前缀树上找到, 查看pass值 (哈希表做不到)





# Greedy

1，实现一个不依靠贪心策略的解法X，可以用最暴力的尝试

2，脑补出贪心策略A、贪心策略B、贪心策略C...

3，用解法X和对数器，用实验的方式得知哪个贪心策略正确

4，不要去纠结贪心策略的证明



题目: 

1.给定一个由字符串组成的数组strs, 必须把所有的字符串拼接起来, 返回所有可能的拼接结果中字典序最小的结果



2.给定一个字符串str, 只由‘X’和‘.’两种字符构成。 ‘X’表示墙，不能放灯，也不需要点亮。‘.’表示居民点，可以放灯，需要点亮如果灯放在i位置，可以让i-1，i和i+1三个位置被点亮返回如果点亮str中所有需要点亮的位置，至少需要几盏灯



3.一块金条切成两半，是需要花费和长度数值一样的铜板的。

比如长度为20的金条，不管怎么切，都要花费20个铜板。 一群人想整分整块金条，怎么分最省铜板? 

例如,给定数组{10,20,30}，代表一共三个人，整块金条长度为60，金条要分成10，20，30三个部分。

如果先把长度60的金条分成10和50，花费60; 再把长度50的金条分成20和30，花费50;一共花费110铜板。

但如果先把长度60的金条分成30和30，花费60;再把长度30金条分成10和20， 花费30;一共花费90铜板。 输入一个数组，返回分割的最小代价。 



4.一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。给你每一个项目开始的时间和结束的时间你来安排宣讲的日程，要求会议室进行的宣讲的场次最多。返回最多的宣讲场次。





5.输入: 正数数组costs、正数数组profits、正数K、正数M

 costs[i]表示i号项目的花费

profits[i]表示i号项目在扣除花费之后还能挣到的钱(利润)

K表示你只能串行的最多做k个项目

M表示你初始的资金

说明: 每做完一个项目，马上获得的收益，可以支持你去做下一个项目。不能并行的做项目。

输出：你最后获得的最大钱数。









# 二叉树 基础

## 先、中、后序遍历

先序: 头左右

中序: 左头右

后序: 左右头

第一次到达一个节点就打印就是先序、第二次打印即中序、第三次即后序

## 递归遍历

递归序



## 迭代遍历

中序iterative写法需要关注



## 按层遍历

### 1.宽度优先遍历: 使用Queue



### 2.通过设置flag的方式, 来发现某一层的结束



### 3.通过一次搞定一层的方法 while + for

相关题目:

求binary tree的最大宽度



## 二叉树的序列化和反序列化

1.可以用先序或者中序或者后序或者按层遍历，来实现二叉树的序列化

2.用什么方式序列化, 就用什么方式反序列化(**其中中序无法反序列化**)

> 431.Encode N-ary Tree to Binary Tree

> 428.Serialize and Deserialize N-ary Tree





题目:

1.设计一个打印整棵树的打印函数



2.给你二叉树中的某个节点X，返回该节点的后继节点 

> 510.Inorder Successor in BST II

- 如果X有右树, 那么后继节点一定是右子树的最左节点
- 如果X没有右树, 一直往上看, 直到某个节点是它父亲的左节点 => 此时X是某个节点左树上的最右
- 如果往上找一直都没找到某个节点符合条件, 那它一定是整棵树的最右侧的叶节点, 那么它没有后继节点





3.请把一段纸条竖着放在桌子上，然后**从纸条的下边向上方对折**1次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。 如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。

给定一个输入参数N，代表纸条都从下边向上方连续对折N次。 请从上到下打印所有折痕的方向。 

例如:N=1时，打印: down N=2时，打印: down down up 







# 二叉树递归套路

可以解决面试中绝大多数的二叉树问题尤其是树型dp问题, 本质是利用递归遍历二叉树的便利性



递归套路步骤:

1）假设以X节点为头，假设可以向X左树和X右树要任何信息

2）在上一步的假设下，讨论以X为头节点的树，得到答案的可能性（最重要）

3）列出所有可能性后，确定到底需要向左树和右树要什么样的信息

4）把左树信息和右树信息求全集，就是任何一棵子树都需要返回的信息S

5）递归函数都返回S，每一棵子树都这么要求

6）写代码，在代码中考虑如何把左树的信息和右树信息整合出整棵树的信息





题目:

1.给定一棵二叉树的头节点head，返回这颗二叉树是不是**平衡二叉树**

```java
class Info{
  boolean isBalanced;
  int height;
}
```

2.给定一棵二叉树的头节点head，返回这颗二叉树是不是**满二叉树(Full Binary Tree)**

> n = 2 ^ h - 1

```java
class Info{
  int nodes;
  int height;
}
```

3.给定一棵二叉树的头节点head，返回这颗二叉树是不是**搜索二叉树 - BST**



4.给定一棵二叉树的头节点head，返回这颗二叉树中是不是**完全二叉树 - CBT**

```java
class Info{
  boolean isCBT;
  boolean isFull;
  int height;
}
```

5.给定一棵二叉树的头节点head，返回这颗二叉树中**最大的二叉搜索子树的大小**

https://leetcode.com/problems/largest-bst-subtree/

```java
class Info{
  boolean isBST;
  int min;
  int max;
  int maxSize;
}
```

6.给定一棵二叉树的头节点head，返回这颗二叉树中**最大的二叉搜索子树的头节点**





7.给定一棵二叉树的头节点head，和另外两个节点a和b, 返回a和b的**最低公共祖先**

https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/

https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/



8.给定一棵二叉树的头节点head，任何两个节点之间都存在距离, 返回**整棵二叉树的最大距离**

Diameter of binary tree  https://leetcode.com/problems/diameter-of-binary-tree/

```java
class Info{
  int maxDistanceInTree;
  int height;
}
```



9.派对的最大快乐值

员工信息的定义如下:

```java
class Employee {
  public int happy; // 这名员工可以带来的快乐值
  List<Employee> subordinates; // 这名员工有哪些直接下级

}
```

 公司的每个员工都符合 Employee 类的描述。整个公司的人员结构可以看作是一棵标准的、 没有环的多叉树。树的头节点是公司唯一的老板。除老板之外的每个员工都有唯一的直接上级。 叶节点是没有任何下属的基层员工(subordinates列表为空)，除基层员工外，每个员工都有一个或多个直接下级。

这个公司现在要办party，你可以决定哪些员工来，哪些员工不来，规则：

1.如果某个员工来了，那么这个员工的所有直接下级都不能来

2.派对的整体快乐值是所有到场员工快乐值的累加

3.你的目标是让派对的整体快乐值尽量大

给定一棵多叉树的头节点boss，请返回派对的最大快乐值。





# UnionFind

1)有若干个样本a、b、c、d…类型假设是V

2)在并查集中一开始认为每个样本都在单独的集合里

3)用户可以在任何时候调用如下两个方法：

​    boolean isSameSet(V x, V y) : 查询样本x和样本y是否属于一个集合

​    void union(V x, V y) : 把x和y各自所在集合的所有样本合并成一个集合

4） isSameSet和union方法的代价越低越好



1）每个节点都有一条往上指的指针

2）节点a往上找到的头节点，叫做a所在集合的代表节点

3）查询x和y是否属于同一个集合，就是看看找到的代表节点是不是一个

4）把x和y各自所在集合的所有点合并成一个集合，只需要小集合的代表点挂在大集合的代表点的下方即可





优化: 

1）节点往上找代表点的过程，把沿途的链变成扁平的

2）小集合挂在大集合的下面

3）如果方法调用很频繁，那么单次调用的代价为O(1)，两个方法都如此



## 应用: 

解决两大块区域的合并问题

常用在图等领域中



https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/





# Graph

图的表示法, 邻接表，邻接矩阵



面试常见图的表示法: 

N*3的matrix

[from, to, weight]

 

或者 只用一维数组

[3, 1, 1, 1]

index -> value

0 -> 3

3 -> 1

2 -> 1

1 -> 1



## BFS

Queue + Set



## DFS

Stack + Set

该DFS的实现要求Stack中保留整条路径



### Cycle Detection









## Topological Sort

要求: 有向无环图  DAG (Directed Acyclic Graph)

应用: 事件安排、编译顺序



- 使用in的值来进行拓扑排序

- 使用BFS, 如果X的点次 > Y的点次, X排在前面, 收集所有Node的点次, 然后使用比较器排序

- 使用DFS, 如果X走出的最大深度 > Y走出的最大深度, X排在前面, 收集所有Node的depth, 然后使用比较器排序

> https://www.lintcode.com/problem/127/



## 最小生成树(Minimum Spanning Tree)

> MST一定是针对无向图  - undirected acyclic graph
>
> https://leetcode.com/problems/connecting-cities-with-minimum-cost/

### Krustal

从weight小的边 -> weight大的边, 依次考察, 但是中途不能成环, 即使一个边的weight很小, 但是它成环了, 那么直接跳过, 考察下一个



从最小的边开始处理(使用堆), 依次选择每个Edge, 当前Edge如果不成环, 就保留此Edge, 判断是否成环使用UnionFind



K算法要检查所有的Edge, 如果图里的Edge特别多, 可以考虑P算法



### Prim

使用minHeap

从任意某个Node出发, 在所有可见Edge中, 选择一个最小的, 然后抵达了一个新的Node, 又解锁一系列Edge, 然后往复进行; 如果某个Edge连接的toNode是解锁过的, 就略过此Edge

 



## Dijkstra

> 一般不处理weight < 0的的情况;  Bottom line: 不能要求环路的累加和为负数, 否则一直绕着环走, 就越变越小

该算法需要一个相对坐标, 一定是给定一个出发点, 即计算图中所有Node距离NodeA的最短距离























https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/









