# Class1

# - - - 经典面试题(十三)

## 1.Longest Increasing Path in a Matrix

给定一个二维数组matrix，可以从任何位置出发，每一步可以走向上、下、左、右，四个方向。返回最大递增链的长度。

例子：

matrix = 

5 4 3

3 1 2

2 1 3

从最中心的1出发，是可以走出1 2 3 4 5的链的，而且这是最长的递增链。所以返回长度5

> lc 329. Longest Increasing Path in a Matrix (Hard)



思路:

以每个(i, j)位置开始递归枚举up, down, left, right四种可能性, 取Max

用Memoization进行优化



## 2. 累加和<=k的子数组累加和

2.给定一个数组arr，再给定一个k值, 返回累加和小于等于k，但是离k最近的子数组累加和



有序表 查找 floorKey或者ceilingKey





## 3. 累加和<=k的子矩阵累加和

> 363   https://src.main.java.leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/

3.给定一个二维数组matrix，再给定一个k值, 返回累加和小于等于k，但是离k最近的子矩阵累加和



先求包含0行且仅包含0行的累加和, 就是调用数组的方法

先求包含0, 1行且仅包含0, 1行的累加和, 把0,1两行数据压缩在一起, 举例如下

![](https://raw.githubusercontent.com/haoboliu66/PicBed/master/img/20210423215236.png)

Hint: 看到矩阵问题, 可以先想一想数组问题怎么解, 然后再在矩阵上进行枚举



## 4. Word Search II

4.给定一个字符类型的二维数组board，和一个字符串组成的列表words。可以从board任何位置出发，每一步可以走向上、下、左、右，四个方向，但是一条路径已经走过的位置，不能重复走。返回words哪些单词可以被走出来

例子 

board = [

 ['o','a','a','n'],

 ['e','t','a','e'],

 ['i','h','k','r'],

 ['i','f','l','v']

]

words = ["oath","pea","eat","rain"]

输出：["eat","oath"]

> lc 79. Word Search (Medium)
>
> lc 212. Word Search II (Hard)



212题使用前缀树优化

前缀树添加pass和end, 用来标记是否收集完了一个字符串

使用pass == 0 来优化, 避免对一个字符串重复走, 如果一个节点的pass是0, 表示这个节点后续的所有字符串都收集完了, 那么后续的路就不用走了, 直接返回



然后跳到了class2 - 第4题



## 5. Expression Add Operators

> 282.Expression Add Operators

5.给定一个只由'0'~'9'字符组成的字符串num，和整数target。可以用+、-和*连接，返回num得到target的所有不同方法

Example 1:

Input: num = "123", target Output: ["1+2+3", "1*2*3"]

Example 2:

Input: num = "232", target Output: ["2*3+2", "2+3*2"]

Example 3:

Input: num = "105", target Output: ["1*0+5","10-5"]

= 6 = 8 = 5

Example 4:

Input: num = "00", target = 0 Output: ["0+0", "0-0", "0*0"]

Example 5:

Input: num = "3456237490", target = 9191 Output: []



结果字符串的长度, 最长不会超过 n + (n - 1)



根据来到 i 位置的字符, 在这个字符前面添加什么, 划分可能性

枚举每一个可能前缀, 然后后续进行dfs

考虑前缀不能有0的边界





# Class2

# - - - 经典面试题(十二)

视频内容上接camp3 - class8

## 1.股票问题(一)

1.给定一个数组arr，从左到右表示昨天从早到晚股票的价格。作为一个事后诸葛亮，你想知道如果只做一次交易，且每次交易只买卖一股，返回能挣到的最大钱数





## 2.股票问题(二)

2.给定一个数组arr，从左到右表示昨天从早到晚股票的价格 作为一个事后诸葛亮，你想知道如果随便交易，

且每次交易只买卖一股，返回能挣到的最大钱数



只要[i+1] > [i] 就榨取一个利润, 分批地处理每个小上坡, 相当于分批处理了一个大上坡



## 3. 股票问题(三)

3.给定一个数组arr，从左到右表示昨天从早到晚股票的价格, 作为一个事后诸葛亮, 你想知道如果交易次数不超过K次, 且每次交易只买卖一股，返回能挣到的最大钱数



斜率优化DP







**经典面试题(十二)截止**





# - - - 经典面试题(十三)

由camp4 - class1跳转 => 02:02:50开始讲解

## 4. Distinct Subsequences 115

4.给定两个字符串S和T，返回S子序列等于T的不同子序列个数有多少个? 如果得到子序列A删除的位置与得到子序列B删除的位置不同，那么认为A和B就是不同的。

【例子】

S = "rabbbit", T = "rabbit"

返回: 3 

是以下三个S的不同子序列，没有^的位置表示删除的位置，因为删除的位置不同，所以这三 个子序列是不一样的

rabbbit

I I  I I II 

rabbbit

I I I  I II 

rabbbit

I I I I  II

 

# - - - 经典面试题(十四)

## 5. Dungeon Game 174

5.给定一个二维数组 map，含义是一张地图，例如，如下矩阵: 

-2 -3  3

-5 -10 1

 0 30 -5

游戏的规则如下: 

骑士从左上角出发，每次只能向右或向下走，最后到达右下角见到公主。

地图中每个位置的值代表骑士要遭遇的事情。

如果是负数，说明此处有怪兽，要让骑士损失血量。

如果是非负数，代表此处有血瓶，能让骑士回血。

骑士从左上角到右下角的过程中，走到任何一个位置时，血量都不能少于1。

为了保证骑士能见到公主，初始血量至少是多少?根据map，返回至少的初始血量。

> lc 174. Dungeon Game







## 6. Cherry Pickup

6.给定一个矩阵matrix，先从左上角开始，每一步只能往右或者往下走，走到右下角。然后从右下角出发，每一步只能往上或者往左走，再回到左上角。任何一个位置的数字，只能获得一遍。返回最大路径和。

>lc 741. Cherry Pickup

> lc 1463. Cherry Pickup II



两个小人, 同时从左上角往右下角走





MIT

String matching: given text T and pattern P

goal: to find all occurrences of P in T as substring





# Class3

## 1. Maximum Gap

1.给定一个无序数组arr，返回如果排序之后，相邻数之间的最大差值

{3,1,7,9}，如果排序后{1,3,7,9}，相邻数之间的最大差值来自3和7，返回4

要求：不能真的进行排序，并且要求在时间复杂度O(N)内解决

> 164.Maximum Gap

如果有N个数字, 分成N+1个桶

最小值一定放在最左侧的桶, 最大值一定放在最右侧的桶内

![](https://raw.githubusercontent.com/haoboliu66/PicBed/master/img/20210509112434.png)

中间某个位置一定存在空桶, 空桶左侧第一个非空桶的Max和空桶右侧第一个非空桶Min的差值, 一定是大于单个桶内部的差值结果, 所以只需要考虑跨桶的情况, 答案不可能来自一个桶内部的差值计算

每个桶只保留最小值和最大值, 不断更新, 不是最大和最小值的直接抛弃

![](https://raw.githubusercontent.com/haoboliu66/PicBed/master/img/20210509112534.png)

最优解不一定来自空桶两侧的桶, 根据空桶两侧max - min得到的值只是一个不平凡的解, 用于舍弃可能性, 舍弃了来自一个桶内部的数字的差值, 只找跨桶的差值即可

举例如下:

![](https://raw.githubusercontent.com/haoboliu66/PicBed/master/img/20210509113328.png)







## 2. Word Break

2.假设所有字符都是小写字母.  长字符串是str

arr是去重的单词表, 每个单词都不是空字符串且可以使用任意次

使用arr中的单词有多少种拼接str的方式，返回方法数.

>lc 139. Word Break
>
>lc 140. Word Break II



从左往右的尝试模型使用暴力递归 + 记忆化搜索可解

使用Trie加速





# 经典面试题(十五)

## 3.二叉树累加和为K的最长路径

> 类似于 求数组中累加和为K的最长子数组 问题

3.给定一棵二叉树的头节点head，和一个数K

路径的定义: 

可以从任何一个点开始，但是只能往下走，往下可以走到任何节点停止

返回路径累加和为K的所有路径中，最长的路径最多有几个节点？



使用Map计算累加和, 记录每个累加和的level, 然后每到一个节点, 都向上在Map里找需要的"前缀值", 每次计算level的差值, 取max即可



## 4. K进制数异或

4.给定一个数组arr，已知除了一种数只出现1次之外，剩下所有的数都出现了k次，如何使用O(1)的额外空间，找到这个数。



准备一个长度32的数组arr, 一个数字如果转换成K进制(K >= 2), 它的长度一定<=32

把每个数字转换成K进制, 然后累加到arr数组上

让arr数组的每个位置都%K, 最后得到的结果转成10进制, 就是想要找的这个数字



因为如果某个数字真的出现了K次, 累加K次到arr数组上, 最后%K, 结果一定是0

假设K=3,  14 => 1 1 2, 加三次就是3 3 6, 无论这个位上是几, 加上去的都是3的倍数, %3之后一定是0



## 5. 水王问题Majority Element

5.给定一个数组arr，如果有某个数出现次数超过了数组长度的一半，打印这个数，如果没有不打印

> lc 169. Majority Element
>
> lc 229. Majority Element II

一次删掉2个不同的数, 2个变量cand, HP, 一次遍历实现



算法模型案例:

国家票选, 每个人写一张选票, 限制: 必须有超过一半的人投某个人, 否则重新投票





5.1 给定一个数组arr和整数k，arr长度为N，如果有某些数出现次数超过了N/K，打印这些数，如果没有不打印

> 结果最多只可能有K-1个候选

一次删掉K个数字, 空间复杂度O(K), 使用Map存储K个候选

候选里的数字只是可能的结果, 还需要单独进行验证



只有当K不大的时候, 时间复杂度较优, 如果K很大, 时间复杂度O(N*K), 因为每个值减1的时候需要遍历







## 附加题: 接咖啡问题

class4的最后一题



给定一个数组arr [3,2,1,7,2] 代表每个咖啡机生产咖啡的工作时长

假设有M个人, 都在0号时间点开始排队, 求每个人能得到咖啡的最早时间点, 返回一个数组, 数组中的值代表每个人能获得咖啡的最早时间

(Heap)





# - - - 经典面试题(十六)

十六 只讲了 2 和 4 (约瑟夫环)

# Class4

## 2. Median of Two Sorted Arrays

2.给定两个整数数组A和B

A是长度为m、元素从小到大排好序了

B是长度为n、元素从小到大排好序了

希望从A和B数组中，找出最大的k个数字

> lc 4. Median of Two Sorted Arrays
> 算法原型: 假设两个有序数组,且长度相等, 求两个数组排序后的上中位数(奇数偶数情况不同)





## 4.约瑟夫环问题

> https://src.main.java.leetcode.com/problems/find-the-winner-of-the-circular-game/
>
> https://src.main.java.leetcode.com/problems/find-the-winner-of-the-circular-game/discuss/1152705/JavaC%2B%2BPython-4-lines-O(n)-time-O(1)-space

约瑟夫环问题: 循环链表, 整数K, 数到K个节点, 移除该节点, 继续数K个节点, 移除; 如此往复, 最后只剩下一个节点, 返回该节点



> 无法模拟, 因为K变大之后会极大影响计算过程性能



### 1.假想公式

假设存在这样的公式 Old = f(New) => **New是被杀之后的编号, 返回被杀之前的编号Old**

因此最后一个节点的时候, N=1, 带入公式求出剩2个节点时的节点编号, 依次调用, 最后调到N的时候就知道了该节点最开始的编号



### 2.节点编号与报数的对应关系

剃刀函数: y = x % i



在环形链表中: 节点编号和所报的数字的对应关系:  (假设没有杀人的环节)

可以由剃刀函数 y = x % i变换得来

![](https://raw.githubusercontent.com/haoboliu66/PicBed/master/img/20210514223348.png)



![](https://raw.githubusercontent.com/haoboliu66/PicBed/master/img/20210514223450.png)



可以看出:  y = x % i 往右移动一位, 再向上移动一位, 就可以得到下面的图像, 对应的函数是 y = (x - 1) % i  +  1, i表示链表的长度

- 从最简单的 剃刀函数/其他函数 去变换, 不要强行找规律



### 3.寻找新旧编号之间的关系

假设旧链表中3号被杀掉了, 寻找新旧链表之间节点编号之间的关系

旧: 1 2 3 4 5 6 7

新: 5 6 x 1 2 3 4

新旧的关系可以画图得出:  x轴为新, y轴为旧

图像就是 y = (x - 1) % i  +  1 向左移动s位

- s表示旧链表中被杀的编
- i表示旧链表的长度

得到: 旧 = (新 + s - 1) % i + 1



在这个公式中, s是未知, 表示旧的链表中被杀的节点编号是s

s是被杀的编号, 每次数到m被杀 => 

上面已经求得: 在环形链表中, 节点编号和报数字之间的关系 s = (m - 1) % i + 1

- 这个公式也就是说, 你给我一个数字m, 我把数到m是哪个节点返回

所以也就有个s的求解方法, 代入新旧关系式, 就得到了我们需要的公式



旧 = (新 +  (m-1)% i ) % i + 1   => 旧 = (新 + m-1) % i + 1



# - - - 经典面试题(十七)

## 1. Building Outline

1.给定一个 N×3 的矩阵 matrix，对于每一个长度为 3 的小数组 arr，都表示一个大楼的三个数 据。arr[0]表示大楼的左边界，arr[1]表示大楼的右边界，arr[2]表示大楼的高度(一定大于 0)。 每座大楼的地基都在 X 轴上，大楼之间可能会有重叠，请返回整体的轮廓线数组。

【举例】 matrix ={{2,5,6}, {1,7,4}, {4,6,7}, {3,6,5}, {10,13,2}, {9,11,3}, {12,14,4},{10,12,5} }

返回: {{1,2,4},{2,4,6}, {4,6,7}, {6,7,4}, {9,10,3}, {10,12,5}, {12,14,4}}







## 3.Nim博弈问题

3.Nim博弈问题

给定一个非负数组，每一个值代表该位置上有几个铜板。a和b玩游戏，a先手，b后手， 轮到某个人的时候，只能在一个位置上拿任意数量的铜板，但是不能不拿。谁最先把铜 板拿完谁赢。假设a和b都极度聪明，请返回获胜者的名字



如果数组异或和为0, 那么先手一定输; 否则后手一定输



## 5. Boats to Save People

> lc 881. Boats to Save People

5.给定一个数组arr，长度为N且每个值都是正数，代表N个人的体重。再给定一个正数 limit，代表一艘船的载重。

以下是坐船规则，

1)每艘船最多只能做两人;

2)乘客 的体重和不能超过limit

返回如果同时让这N个人过河最少需要几条船。





## 6. Coffee Machine Problem

6.数组arr代表每一个咖啡机冲一杯咖啡的时间，每个咖啡机只能串行的制造咖啡。现在有n个人需要喝咖啡，只能用咖啡机来制造咖啡。认为每个人喝咖啡的时间非常短，冲好的时间即是喝完的时间。每个人喝完之后咖啡杯可以选择洗或者自然挥发干净，只有一台洗咖啡杯的机器，只能串行的洗咖啡杯。洗杯子的机器洗完一个杯子时间为a，任何一个杯子自然挥发干净的时间为b。

四个参数：arr, n, a, b

假设时间点从0开始，返回所有人喝完咖啡并洗完咖啡杯的全部过程结束后，至少来到什么时间点。





# Class5

# - - - 经典面试题(十八)

## 1.最长回文子序列长度

> https://src.main.java.leetcode.com/problems/longest-palindromic-subsequence/
>
> 回文: 范围尝试

1.给定一个字符串str，求最长回文子序列长度

解法1: 原串和逆序串, 求最长公共子序列

解法2: 原串自己进行对应, [L...R]范围上的尝试模型



## 2. 蛇蛇游戏

2.给定一个二维数组matrix，每个单元都是一个整数，有正有负。最开始的时候小Q操纵 一条长度为0的蛇蛇从矩阵最左侧任选一个单元格进入地图，蛇每次只能够到达当前位 置的右上相邻，右侧相邻和右下相邻的单元格。蛇蛇到达一个单元格后，自身的长度会 瞬间加上该单元格的数值，任何情况下长度为负则游戏结束。小Q是个天才，他拥有一 个超能力，可以在游戏开始的时候把地图中的某一个节点的值变为其相反数(注:最多 只能改变一个节点)。问在小Q游戏过程中，他的蛇蛇最长长度可以到多少?

比如:

1 -4  10

3 -2 -1

2 -1  0

0  5 -2

最优路径为从最左侧的3开始，3 -> -4(利用能力变成4) -> 10。所以返回17。





## 3. Basic Calculator

>  类似题: https://src.main.java.leetcode.com/problems/number-of-atoms/

3.给定一个字符串str，str表示一个公式，公式里可能有整数、加减乘除符号和左右 括号，返回公式的计算结果。

【举例】

str="48*((70-65)-43)+8*1"，返回-1816。

str="3+1*4"，返回7。

str="3+(1*4)"，返回7。

【说明】 1.可以认为给定的字符串一定是正确的公式，即不需要对str做公式有效性检查。 2.如果是负数，就需要用括号括起来，比如"4*(-3)"。但如果负数作为公式的开头 或括号部分的开头，则可以没有括号，比如"-3*4"和"(-3*4)"都是合法的。 3.不用考虑计算过程中会发生溢出的情况。

>lc 227. Basic Calculator II - medium
>
>lc 228. Basic Calculator - hard



先考虑没有括号的情况怎么计算(Basic Calculator II)  一个栈即可解决, 用栈先把乘除计算合并完, 最后统一在栈中计算加减



有括号的情况:

遇到左括号就调用递归执行后续过程, 遇到了与他匹配的右括号就退出当前递归栈



套路可以用于任何嵌套的字符串解析

a a 7 { b k 3 {ab} }





## 4.牛牛回文串问题(复杂DP)

4.对于一个字符串, 从前开始读和从后开始读是一样的, 我们就称这个字符串是回文串。例如"ABCBA","AA", "A" 是回文串, 而"ABCD", "AAB"不是回文串。牛牛特别喜欢回文串, 他手中有一个字符串s, 牛牛在思考能否从字 符串中移除部分(0个或多个)字符使其变为回文串，并且牛牛认为空串不是回文串。牛牛发现移除的方案可能有 很多种, 希望你来帮他计算一下一共有多少种移除方案可以使s变为回文串。对于两种移除方案, 如果移除的字 符依次构成的序列不一样就是不同的方案。

例如，XXY 4种 ABA 5种

【说明】 这是今年的原题，提供的说明和例子都很让人费解。现在根据当时题目的所有测试用例，重新解释当时的题目 含义: 1)"1AB23CD21"，你可以选择删除A、B、C、D，然后剩下子序列{1,2,3,2,1}，只要剩下的子序列是同一个，那 么就只算1种方法，和A、B、C、D选择什么样的删除顺序没有关系。 2)"121A1"，其中有两个{1,2,1}的子序列，第一个{1,2,1}是由{位置0，位置1，位置2}构成，第二个{1,2,1} 是由{位置0，位置1，位置4}构成。这两个子序列被认为是不同的子序列。也就是说在本题中，认为字面值一样 但是位置不同的字符就是不同的。 3)其实这道题是想求，str中有多少个不同的子序列，每一种子序列只对应一种删除方法，那就是把多余的东 西去掉，而和去掉的顺序无关。

4)也许你觉得我的解释很荒谬，但真的是这样，不然解释不了为什么，XXY 4种 ABA 5种，而且其他的测 试用例都印证了这一点。





# 经典面试题(十九)

# Class6

## 1.数字裂开的ways

1.给定一个正数1，裂开的方法有一种，(1) 给定一个正数2，裂开的方法有两种，(1和1)、(2) 给定一个正数3，裂开的方法有三种，(1、1、1)、(1、2)、(3) 给定一个正数4，裂开的方法有五种，(1、1、1、1)、(1、1、2)、(1、3)、(2、2)、 (4)

给定一个正数n，求裂开的方法数。 动态规划优化状态依赖的技巧





## 2.逆序对问题

> lc 629. K Inverse Pairs Array
> 逆序对问题

2.给定一个整数N，代表你有1～N这些数字。在给定一个整数K。你可以随意排列这些数字，但是每一种排列都有若干个逆序对。返回有多少种排列，正好有K个逆序对

例子1:

Input: n = 3, k = 0

Output: 1

解释: 只有[1,2,3]这一个排列有0个逆序对。 

例子2:

Input: n = 3, k = 1

Output: 2

解释: [3,2,1]有(3,2)、(3,1)、(2,1)三个逆序对，所以不达标。

达标的只有：

[1,3,2]只有(3,2)这一个逆序对，所以达标。

[2,1,3]只有(2,1)这一个逆序对，所以达标。



dp [i] [j] => [1...i] 组成 j 个逆序对

涉及 斜率优化



# 经典面试题(二十)

## 3. 最大BST拓扑结构

3.给定一棵二叉树的头节点head，已知所有节点的值都不一样，返回其中最大的且符 合搜索二叉树条件的最大拓扑结构的大小。 

拓扑结构：不是子树，只要能连起来的结构都算。





## 4. 完美洗牌问题

https://src.main.java.leetcode.com/problems/wiggle-sort/

https://src.main.java.leetcode.com/problems/wiggle-sort-ii/



4.给定一个长度为偶数的数组arr，长度记为2*N。前N个为左部分，后N个为右部分。 arr就可以表示为{L1,L2,..,Ln,R1,R2,..,Rn}， 请将数组调整成{R1,L1,R2,L2,..,Rn,Ln}的样子。

https://src.main.java.leetcode.com/problems/shuffle-the-array/

**使用额外空间**的做法: 两个指针, 数据拷贝进一个新数组返回



**不使用额外空间**的做法:  in-place



长度为2*N的数组, 对于一个位置, 它最终要去哪个位置, 是一个简单公式可以确定的:  f(i, N) 

i > N 时 =>  (i - N) * 2 - 1

i <= N时 =>  i * 2

 

下标循环怼

但是如果N为奇数, 下标循环怼会失效, 因为会有不同的环



完美洗牌问题结论:   (证明略)

当数组总长度为 3 ^k^ - 1 (k > 0) 的情况下, 所有环的出发点是1, 3, 9 .... 3^k-1^



插入另一个涉及的算法原型 **Rotate Array**:

https://src.main.java.leetcode.com/problems/rotate-array/ 

abcde fgh  k = 5  表示 左半部分是5的长度, 要把数组变成 fgh abcde

算法流程: **左部分逆序, 右部分逆序, 整体再逆序**



回到shuffle array的题目

假设给的长度是14, 找到离这个长度最近的 3 ^k^ - 1, 是长度为8 (i.e 有2个出发点1和3)

![](https://raw.githubusercontent.com/haoboliu66/PicBed/master/img/20210628221804.png)

在长度为8的范围内, 进行下标循环怼, 调整完一个可以得到: 

![](https://raw.githubusercontent.com/haoboliu66/PicBed/master/img/20210628221850.png)

所以这个问题就变成了: 调整剩下的长度为6的部分

那么中间的部分怎么得来? 即如何划出左半部分有长度为8的可进行下标循环怼的部分?

把L5 L6 L7和R1 R2 R3 R4进行Rotate-Array的算法变换

就可以得到 L5 L6 L7 R1 R2 R3 R4  => R1 R2 R3 R4 L5 L6 L7



剩下长度为6的部分, 再去用3^k^ - 1的值去拆分, 直到剩余长度为0



# Class7

## 3. 可见山峰对问题

3.一个不含有负数的数组可以代表一圈环形山，每个位置的值代表山的高度。比如， {3,1,2,4,5}、{4,5,3,1,2}或{1,2,4,5,3}都代表同样结构的环形山。 山峰A和山峰B能够相互看见的条件为: 1.如果A和B是同一座山，认为不能相互看见。 2.如果A和B是不同的山，并且在环中相邻，认为可以相互看见。 3.如果A和B是不同的山，并且在环中不相邻，假设两座山高度的最小值为min。

1)如果A通过顺时针方向到B的途中没有高度比min大的山峰，认为A和B可以相互 看见

2)如果A通过逆时针方向到B的途中没有高度比min大的山峰，认为A和B可以相互 看见

3)两个方向只要有一个能看见，就算A和B可以相互看见 

给定一个不含有负数且没有重复值的数组 arr，请返回有多少对山峰能够相互看见



如果数组中没有重复值: **时间复杂度O(1)可以搞定**

1个数字 0对

2个数字 1对

3个数字 3对

**找可见山峰对原则: 小 找 大, 可以自动去重**

![](https://raw.githubusercontent.com/haoboliu66/PicBed/master/img/20210629113553.png)

如果某个任意点X, 它顺时针方向找到的第一个离他最近且大于X的点, 假设是Y (Y也可能是max);

它逆时针方向找到的第一个离他最近且大于X的点, 假设是Z (Z也可能是次max);

因为我们规定的原则是小找大, 所以X自己有且仅有2个对不相邻的可见山峰对

除去最大和次大2个点, 还有N-2个点, 每个点产生2个, 再加上最后一对, 次大望向最大, 所以总数是 2 * (N - 2) + 1



问题: 这种算法会不会和相邻的山峰对计算重复？

不会, 因为规定小找大, 会把这种情况排除





**进阶**: 给定一个不含有负数但可能含有重复值的数组arr，返回有多少对山峰能够相互看见。



实现arr环形遍历的机制

找到数组的最大值, 最大值可能不只一个, 随便拿一个



准备一个栈, 单调递减, 栈底到栈顶依次递增

- 栈中的值 {5, 1}  5发现了1次

从最大值出发, 如果最大值有多个, 从任意的一个出发

当某个数字cur让栈无法继续单调递减时, 表明: 此时我至少可以结算栈顶的第一个元素了, 因为它遇到了比它大的这个cur, 所以,弹出栈顶元素, 就可以找到栈顶元素在两个方向上比它大的两个数字 (单调栈性质)



假设一个数字弹出来 a, 有k个

对外产生个数: 2 * k

对内产生个数: C(k,2)



最后一步:还要单独结算栈内部剩下的值: 

栈中的最后两条数据比较特殊, 其他的数据结算公式同上

结算倒数第二条: 如果max只有1个, 外部 1*k, 内部C(k,2)

结算倒数第一条: 外部为0, 内部C(k,2)



# 经典面试题(二十一)

## 1.

1.项目有四个信息:

1)哪个项目经理提的

2)被项目经理润色出来的时间点

3)项目优先级

4)项目花费的时间

项目经理们可以提交项目给程序员们，程序员可以做这些项目。

比如长度为4的数组[1, 3, 2, 2]，表示1号项目经理提的，被项目经理润色出来的时间点是3，优先级2，花 费程序员2个时间。

所以给一个N*4的矩阵，就可以代表N个项目。 给定一个正数pm，表示项目经理的数量，每个项目经理只负责自己的那些项目，并且一次只能提交一个项目 给程序员们，这个提交的项目做完了，才能再次提交。 经理对项目越喜欢，就会越早提交。一个项目优先级越高越被喜欢;如果优先级一样，花费时间越少越喜欢; 如果还一样，被项目经理润色出来的时间点越早越喜欢。 给定一个正数sde，表示程序员的数量，所有经理提交了的项目，程序员会选自己喜欢的项目做，每个人做 完了一个项目，然后才会再来挑选。 当程序员在挑选项目时，有自己的喜欢标准。一个项目花费时间越少越被喜欢;如果花费时间一样，该项目 的负责人编号越小越被喜欢。

返回一个长度为N的数组，表示N个项目的结束时间。

比如:

int pms = 2;

int sde = 2;

int[][] programs = { { 1, 1, 1, 2 }, { 1, 2, 1, 1 }, { 1, 3, 2, 2 }, { 2, 1, 1, 2 }, { 2, 3, 5, 5 } };

返回:{3, 4, 5, 3, 9}



## 2. Recovery BST

> 99.Recover Binary Search Tree  https://src.main.java.leetcode.com/problems/recover-binary-search-tree/

2.一棵二叉树原本是搜索二叉树，但是其中有两个节点调换了位置，使得这棵二叉树不再 是搜索二叉树，请找到这两个错误节点并返回。 已知二叉树中所有节点的值都不一样，给定二叉树的头节点 head，返回一个长度为2的 二叉树节点类型的数组errs，errs[0]表示一个错误节点， errs[1]表示另一个错误节 点。

进阶: 如果在原问题中得到了这两个错误节点，我们当然可以通过交换两个节点的节点值的方 式让整棵二叉树重新成为搜索二叉树。 但现在要求你不能这么做，而是在结构上完全交换两个节点的位置，请实现调整的函数







## 4. 非负数组子序列和 % m 最大

4.给定一个非负数组arr，和一个正数m, 返回arr的所有子序列中累加和%m之后的最大值。

> 根据数据量猜解法





# Class8

## 1. Regular Expression Matching

> lc 10. Regular Expression Matching

1.判定一个由[a-z]字符构成的字符串和一个包含'?'和'*'通配符的字符串是否匹配。 通配符'?'匹配任意单一字符,'*'匹配任意多个字符包括0个字符。 字符串长度不会超过100，字符串不为空。

输入描述:

字符串 str 和包含通配符的字符串 pattern。1 <= 字符串长度 <= 100输出描述: true 表示匹配，false 表示不匹配



## 2. Freedom Trail

2.



> lc 514. Freedom Trail



## 3. Burst Balloons

> lc 312. Burst Balloons

3.给定一个数组 arr，代表一排有分数的气球。每打爆一个气球都能获得分数，假设打爆气 球 的分数为 X，获得分数的规则如下: 1)如果被打爆气球的左边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 L;如果被打爆气球的右边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 R。 获得分数为 L*X*R。 2)如果被打爆气球的左边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 L;如果被打爆气球的右边所有气球都已经被打爆。获得分数为 L*X。 3)如果被打爆气球的左边所有的气球都已经被打爆;如果被打爆气球的右边有没被打爆的 气球，找到离被打爆气球最近的气球，假设分数为 R;如果被打爆气球的右边所有气球都 已经 被打爆。获得分数为 X*R。 4)如果被打爆气球的左边和右边所有的气球都已经被打爆。获得分数为 X。

目标是打爆所有气球，获得每次打爆的分数。通过选择打爆气球的顺序，可以得到不同的总分，请返回能获得的最大分数。

【举例】

arr = {3,2,5} 如果先打爆3，获得3*2;再打爆2，获得2*5;最后打爆5，获得5;最后总分21 如果先打爆3，获得3*2;再打爆5，获得2*5;最后打爆2，获得2;最后总分18 如果先打爆2，获得3*2*5;再打爆3，获得3*5;最后打爆5，获得5;最后总分50 如果先打爆2，获得3*2*5;再打爆5，获得3*5;最后打爆3，获得3;最后总分48 如果先打爆5，获得2*5;再打爆3，获得3*2;最后打爆2，获得2;最后总分18 如果先打爆5，获得2*5;再打爆2，获得3*2;最后打爆3，获得3;最后总分19 返回能获得的最大分数为50







## 4. 汉诺塔最优轨迹判定

4.汉诺塔游戏的要求把所有的圆盘从左边都移到右边的柱子上，给定一个整型数组arr， 其中只含有1、2和3，代表所有圆盘目前的状态，1代表左柱，2代表中柱，3代表右柱， arr[i]的值代表第i+1个圆盘的位置。 比如，arr=[3,3,2,1]，代表第1个圆盘在右柱上、第2个圆盘在右柱上、第3个圆盘在中 柱上、第4个圆盘在左柱上 如果arr代表的状态是最优移动轨迹过程中出现的状态，返回arr这种状态是最优移动轨 迹中的第几个状态;如果arr代表的状态不是最优移动轨迹过程中出现的状态，则返回- 1。



process(int[] arr, int level, int from, int to, int other)





## 5. Minimum Cost to Merge Stones

> lc 1000. Minimum Cost to Merge Stones
>
> lc 1167. Minimum Cost to Connect Sticks

5.给定一个数组arr，和一个整数k。

这代表你可以把相邻的k个数字合成一个数字，每一次合并的代价是这些数字的累加和。

最终你的目标是把arr中所有数字合成一个，返回最小代价。



Input: stones = [3,2,4,1], K = 2

Output: 20

解释:

一开始是[3, 2, 4, 1]，只能相邻的2个数字合成一个数字。

先合并[3, 2]变成5，代价是5。 那么就得到了[5, 4, 1]。

先合并[4, 1]变成5，代价是5。 那么就得到了[5, 5]。

先合并[5, 5]变成10，代价是10。 那么就得到了一个数字10。

总代价是20，而且这种方案是最省的。



Input: stones = [3,2,4,1], K = 3

Output: -1

解释：

只能相邻的3个数字合成一个数字，那么合并一次，数字就不够了。所以返回-1。

Input: stones = [3,5,1,2,6], K = 3

Output: 25

解释

开始是[3, 5, 1, 2, 6]，只能相邻的3个数字合成一个数字。

先合并[5, 1, 2]变成8，代价是8, 就变成了[3, 8, 6]

再合并[3, 8, 6]变成17，代价17，就变成了[17]

总代价是25，而且是所有方案中最小的。



