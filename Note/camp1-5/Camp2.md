23280703668983



# 1.打表技巧和矩阵处理技巧

 ## 打表找规律

1）某个面试题，输入参数类型简单，并且只有一个实际参数

2）要求的返回值类型也简单，并且只有一个

3）用暴力方法，把输入参数对应的返回值，打印出来看看，进而优化code



## 题目

1.小虎去买苹果，商店只提供两种类型的塑料袋，每种类型都有任意数量。

1）能装下6个苹果的袋子

2）能装下8个苹果的袋子

小虎可以自由使用两种袋子来装苹果，但是小虎有强迫症，他要求自己使用的袋子数量必须最少，且使用的每个袋子必须装满。

给定一个正整数N，返回至少使用多少袋子。如果N无法让使用的每个袋子必须装满，返回-1





2.给定一个正整数N，表示有N份青草统一堆放在仓库里, 有一只牛和一只羊，牛先吃，羊后吃，它俩轮流吃草

不管是牛还是羊，每一轮能吃的草量必须是：

1，4，16，64…(4的某次方)

谁最先把草吃完，谁获胜

假设牛和羊都绝顶聪明，都想赢，都会做出理性的决定

根据唯一的参数N，返回谁会赢



3.定义一种数：可以表示成若干（数量>1）连续正数和的数

比如:

5 = 2+3，5就是这样的数

12 = 3+4+5，12就是这样的数

1不是这样的数，因为要求数量大于1个、连续正数和

2 = 1 + 1，2也不是，因为等号右边不是连续正数

给定一个参数N，返回是不是可以表示成若干连续正数和的数





小trick: 判断一个数字是不是2^N 

```java
num & (num - 1) == 0
```



**附加题:**

一个数组, [T,F,T,T,F,F,T,F,T,F,T], 两个人依次操作, 对[i]位置的操作, 可以让[i]往后全都变相反, 先让所有位置全变T的人赢, 判断最后谁会赢 / 谁不一定不会输?

看数组最后一个位置, 如果最后一个位置是T, 那先手永远不可能赢, 因为他不论在什么位置操作, 都会让最后一个位置变成F;

可以打表找规律, 会发现只和最后一个位置的值有关



## 矩阵处理

 1）zigzag打印矩阵



2）转圈打印矩阵



3）原地旋转正方形矩阵



核心技巧：找到coding上的宏观调度

 

 

# 2.数组三连

问题1: 给定一个正整数组成的无序数组arr, 给定一个正整数值K, 找到arr的所有子数组里, 哪个子数组的累加和等于K, 并且是长度最大的, 返回其长度

正数数组 ==> 单调性 ==> 滑动窗口或双指针

以每个位置[i]开头的情况下, 找到所有答案



问题2: 给定一个整数组成的无序数组arr, 值可能正、可能负、可能0,给定一个整数值K, 找到arr的所有子数组里, 哪个子数组的累加和等于K,并且是长度最大的, 返回其长度

以每个位置[i]结尾的情况下, 找到所有答案; 用Map记录某个累加和最早出现的位置



类似问题: 一个数组arr[] 有正数,有负数, 有0, 求含有1和2的数量相同的最长子数组长度



问题3: 给定一个整数组成的无序数组arr, 值可能正、可能负、可能0, 给定一个整数值K, 找到arr的所有子数组里, 哪个子数组的累加和<=K, 并且是长度最大的, 返回其长度

记录[i]位置向后,所有累加和中最小值 和 其最右边界, 分别记录在2个数组中 (预处理结构)

- **minSum[i]**  ===> i 位置向后,所有累加和中最小值

- **minSumEnd[i]**  ===>  i 位置向后,所有累加和中最小值的最右边界

从右向左遍历, 把两个辅助数组填好



主流程: 也是看以每个位置[i]开头的情况, 假设目标累加和K=30

假设minSum[0] = 35, 即可判断出以0位置开头的子数组中, 没有答案

假设minSum[0] = 5, minSumEnd[0] =7, 即 0~7第一块达标, 再从8开始扩, 继续累加

<img src="https://raw.githubusercontent.com/haoboliu66/PicBed/master/img/20201107151346.png" style="zoom:50%;" />

可能性的舍弃:

假设0-29都达标, 累加和是90, 算出1-29的累加和 == 90 - arr[0]

看看减去0位置的数之后, 30对应的块能不能加进来, 而且判断会不会更长





# 3.哈希函数和岛问题

## 哈希函数

1.输入值无穷大

2.输出值有限范围

3.无随机机制, 相同的input, 一定得到相同的output  (same in same out)

4.不同的input也可能产生相同的output(哈希碰撞)

5.离散性和均匀性



哈希函数的结果是hexodecimal表示的一串数字



哈希表的实现:

假设哈希表最差的实现情况: 当链的长度等于cap + 1时, 就要扩容, 所以扩容时的数据代价:

2, 3, 5, 9, 17, 33 ...... N 接近于二倍的增长趋势, 所以如果想要扩容到N, 经历的是logN的变化

等比数列, 扩容到N的复杂度是O(N), 均摊到每次操作就是O(1)



扩容次数的复杂度:  扩容是根据已有数据量进行扩容并重新分配位置, 扩容时数据量是: 1, 2, ,4, 8, ...... N / 4, N / 2

1 + 2 + 4 + 8 + .... +  N / 4 + N / 2  等比数列收敛到O(N), 均摊到每个数就是O(1)

哈希表的桶里放有序表(红黑树)优化链表结构







## 布隆过滤器(Bloom Filter)  

类似黑名单系统(没有删除行为的黑名单系统)



假设一个爬虫公司, 很多爬虫去爬url, 在一个系统中存着已经爬过的url, 避免重复爬

假设用哈希表, 有100亿个url, 只存key 4Byte, 需要6400亿字节的内存空间(640G), 太浪费

布隆过滤器支持建立黑名单系统, 并且能极大节省空间



### bitmap

位图 bit数组, 每个位置只有0或1

基础的int数组用位图实现



![](https://raw.githubusercontent.com/haoboliu66/PicBed/master/img/20210710102918.png)

\# 一个初始长度为100的int数组包含3200个bit

假设要提取的是453bit位的数字状态:

判断453位的bit是0还是1, 将该bit右移至2进制的最右侧, 然后 & 1, 即可判断是0还是1

453位所在的组是(453/32)这个组所在的数字, 是该数字的第(453 % 32) 位

![](https://raw.githubusercontent.com/haoboliu66/PicBed/master/img/20210710102941.png)



int[] 数组最长是Integer.MAX_VALUE

long[]数组最长也是Integer.MAX_VALUE

最大值是2^31, 大概2G; 如果是long的最大值,可以达到2^63, 内存不会有这么大去放数组





用二维的矩阵也可以表示位图

100 * 100的矩阵总共有320000个bit

![](https://raw.githubusercontent.com/haoboliu66/PicBed/master/img/20210710103019.png)

> 如果下标不够用了, 可以通过维度扩展来增加bit



布隆过滤器就是使用位图,长度为m, 对于每个url使用k个哈希函数,得到k个哈希值都%m, 对应位图中的k个点标记(k个位置中可能有重复的); 如果一个url对应的所有点都标记了, 就是黑名单

![](https://raw.githubusercontent.com/haoboliu66/PicBed/master/img/20210710104117.png)



问题的关键在于bitmap的容量m定多大, 哈希函数的个数k是几个?

**布隆过滤器一定存在失误率**, 但是失误类型是误杀(将好标记位坏, 而不会错过任何一个坏), 而且布隆过滤器不支持黑名单的删除

m和k是基于样本量确定的, 必须一开始就指定



### 布隆过滤器的设计

布隆过滤器的容量只需要考虑

1. 样本量 N

2. 失误率 P

   

![](https://raw.githubusercontent.com/haoboliu66/PicBed/master/img/20210710103102.png)

如果工程业务上事先指定一个失误率P,就 可以找到一个合适的M, 既能省空间, 又能满足该失误率







![](https://raw.githubusercontent.com/haoboliu66/PicBed/master/img/20210710104839.png)

根据第二个公式可以求出根据容量m和失误率得到的最佳哈希函数个数k



![](https://raw.githubusercontent.com/haoboliu66/PicBed/master/img/20210710104636.png)





### 如何加工出多个哈希函数

![](https://raw.githubusercontent.com/haoboliu66/PicBed/master/img/20210710105624.png)









## 一致性哈希 - Consistent hashing

解决数据存储问题

### 经典服务器结构

![](https://raw.githubusercontent.com/haoboliu66/PicBed/master/img/20210710110616.png)

选择良好的hashkey, 让数据存储分部均衡



传统复杂均衡底层数据服务器的问题:

增加机器和减少机器的数据迁移代价较大

假设业务量是1亿, 3台机器; 突然业务量增大到10亿, 需要6台机器; 需要把原来每台机器的key都拿出来重新取模6;  每次增减机器都要进行全量数据迁移; 

对于弹性业务量, 一致性哈希就可以做到负载均衡且迁移代价低





如何保证3台机器把环均分?



### **虚拟节点技术 - Virtual nodes**

#### 负载均衡

不再使用机器的hostname或某个属性去占环, 而是每个机器分配一定数量的字符串, 比如1000, 每个机器用1000个点去占环, 按比例来算, 每个机器占有三分之一;   点数越多, 分配的越均衡

![](https://raw.githubusercontent.com/haoboliu66/PicBed/master/img/20210710112032.png)如果突然加了m4, 也是用1000个点去抢环, 分配完按比例依然是每个机器四分之一



#### 负载管理

如果机器m1的性能是m2和m3性能的两倍, m4性能是m2的一半,那么此方法也可以实现负载管理;  m1分配2000个虚拟节点, m2和m3只分配1000个, m4只分配500个, 按比例分配负载



一致性哈希的产品

e.g. aws dynamodb



Amazon仓库物品摆放不是按类摆放, 而是每种物品按照哈希算法分配, 每种物品都散步在整个空间里; 挑货的时候, 可以走最小路径调完, 相当于每个区域都有所有商品





# 4.资源限制类题目

![](https://raw.githubusercontent.com/haoboliu66/PicBed/master/img/20210710132442.png)



题目一

32位无符号整数的范围是0~4,294,967,295，现在有一个正好包含40亿个无符号整数的文件，

可以使用最多1GB的内存，怎么找到出现次数最多的数？



如果用1G内存做哈希表, K是数字, V是次数

Key是4Byte, Value也是4Byte, 一条记录占8字节

如果40亿个整数都不一样, 最差有40亿条记录, 总共需要320亿字节(32G), 所以1G内存明显不能这么操作

40亿条记录, 需要32G内存, 那么1G内存可以保存的记录数是40/32, 保守估计认为是40/40, 所以1G内存放1亿条记录

![](https://raw.githubusercontent.com/haoboliu66/PicBed/master/img/20210710132626.png)



让每个数字过一遍哈希函数, 并%40, 得到0....39, 放入对应编号的文件, 由于哈希函数的性质可知, 相同的数字一定会被写入同一个编号的文件

假设有S种不同的数,  0...39号文件含有不同数字的数量几乎均等

所以每个文件中不同的数字大概率不会超过1亿条, 这时哈希表就够用了

每个文件过一遍, 然后选出每个里面的top1, 最后40个再筛一遍选最大





题目二

32位无符号整数的范围是0~4,294,967,295，现在有一个正好包含40亿个无符号整数的文件，

所以在整个范围中必然存在没出现过的数。

可以使用最多1GB的内存，怎么找到所有未出现过的数？

【进阶】

内存限制为 3KB，但是只用找到一个没出现过的数即可



题目三

有一个包含100亿个URL的大文件，假设每个URL占用64B，

请找出其中所有重复的URL

【补充】

某搜索公司一天的用户搜索词汇是海量的(百亿数据量)，

请设计一种求出每天热门Top100词汇的可行办法





题目四

32位无符号整数的范围是0~4294967295，

现在有40亿个无符号整数，

可以使用最多1GB的内存，

找出所有出现了两次的数。





题目五

32位无符号整数的范围是0~4294967295，现在有40亿个无符号整数

可以使用最多3K的内存，怎么找到这40亿个整数的中位数？





题目六

32位无符号整数的范围是0~4294967295，

有一个10G大小的文件，每一行都装着这种类型的数字，

整个文件是无序的，给你5G的内存空间，

请你输出一个10G大小的文件，就是原文件所有数字排序的结果









# 5.有序表

裸的BST的问题:

输入数据状况决定性能: 数据问题导致树的不平衡, 复杂度无法保持在O(logN)

具备自平衡能力, 维持平衡的代价不超过O(logN)















# 6.AC自动机







# 7.卡特兰数(实际视频讲解在Camp3)

二叉树有N个节点, 有多少种不同的构成方式: 



