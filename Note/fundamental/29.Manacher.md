# Graph

图的表示法, 邻接表，邻接矩阵

面试常见图的表示法:

N*3的matrix

[from, to, weight]

或者 只用一维数组

[3, 1, 1, 1]

index -> value

0 -> 3

3 -> 1

2 -> 1

1 -> 1

## BFS

Queue + Set

## DFS

Stack + Set

该DFS的实现要求Stack中保留整条路径

### Cycle Detection

## Topological Sort

要求: 有向无环图 DAG (Directed Acyclic Graph)

应用: 事件安排、编译顺序

- 使用in的值来进行拓扑排序

- 使用BFS, 如果X的点次 > Y的点次, X排在前面, 收集所有Node的点次, 然后使用比较器排序

- 使用DFS, 如果X走出的最大深度 > Y走出的最大深度, X排在前面, 收集所有Node的depth, 然后使用比较器排序

> [LintCode 炼码](https://www.lintcode.com/problem/127/)







## 最小生成树(Minimum Spanning Tree)

> MST一定是针对无向图 - undirected acyclic graph
> 
> https://src.main.java.com.hliu.leetcode.com/problems/connecting-cities-with-minimum-cost/

### Krustal

从weight小的边 -> weight大的边, 依次考察, 但是中途不能成环, 即使一个边的weight很小, 但是它成环了, 那么直接跳过, 考察下一个

从最小的边开始处理(使用堆), 依次选择每个Edge, 当前Edge如果不成环, 就保留此Edge, 判断是否成环使用UnionFind

K算法要检查所有的Edge, 如果图里的Edge特别多, 可以考虑P算法

### Prim

使用minHeap

从任意某个Node出发, 在所有可见Edge中, 选择一个最小的, 然后抵达了一个新的Node, 又解锁一系列Edge, 然后往复进行; 如果某个Edge连接的toNode是解锁过的, 就略过此Edge

## Dijkstra

> 一般不处理weight < 0的的情况; Bottom line: 不能要求环路的累加和为负数, 否则一直绕着环走, 就越变越小

该算法需要一个相对坐标, 一定是给定一个出发点, 即计算图中所有Node距离NodeA的最短距离

https://src.main.java.com.hliu.leetcode.com/problems/remove-all-adjacent-duplicates-in-string/

# 
