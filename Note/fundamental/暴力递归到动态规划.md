# 暴力递归

## 递归尝试

1.使用递归逆序一个Stack

> Stack[3,2,1], 递归取出bottom, 用递归栈保存, 再依次返回





## 从左往右的尝试模型

1.Decode ways

规定1和A对应、2和B对应、3和C对应...

那么一个数字字符串比如"111”就可以转化为:

"AAA"、"KA"和"AK"

给定一个只有数字字符组成的字符串str，返回有多少种转化结果 





2.背包问题

给定两个长度都为N的数组weights和values，

weights[i]和values[i]分别代表 i号物品的重量和价值。

给定一个正数bag，表示一个载重bag的袋子，

你装的物品不能超过这个重量。

返回你能装下最多的价值是多少? 



## 范围上尝试的模型

1.取牌问题

给定一个整型数组arr，代表数值不同的纸牌排成一条线，

玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后拿，

但是每个玩家每次只能拿走最左或最右的纸牌， 玩家A和玩家B都绝顶聪明。请返回最后获胜者的分数





打印n层汉诺塔从最左边移动到最右边的全部过程





打印一个字符串的全部子序列 - String Subsequence

打印一个字符串的全部子序列，要求不要出现重复字面值的子序列



打印一个字符串的全部排列 - String Permutation

打印一个字符串的全部排列，要求不要出现重复的排列





N皇后问题

N皇后问题是指在N*N的棋盘上要摆N个皇后，

要求任何两个皇后不同行、不同列， 也不在同一条斜线上


 给定一个整数n，返回n皇后的摆法有多少种。
 n=1，返回1

n=2或3，2皇后和3皇后问题无论怎么摆都不行，返回0

n=8，返回92





## 暴力递归设计原则

1）每一个可变参数的类型，一定不要比int类型更加复杂

2）原则1）可以违反，让类型突破到一维线性结构，那必须是单一可变参数

3）如果发现原则1）被违反，但不违反原则2），只需要做到记忆化搜索即可

4）可变参数的个数，能少则少





# 四边形不等式技巧(上)

入门题 (题目一)

非负数组arr, 求在此数组上的最佳切分位置, 使得左右两部分 累加和的最小值 尽可能大



进阶问题 (题目二)

求在每个位置上的答案, 即分别在0...1, 0...2, 0...3, 0...4, 0....N上切割的答案(返回一个数组) 



进一步抽象化: 

在某指标的 最差中 取最优

![](https://raw.githubusercontent.com/haoboliu66/PicBed/master/img/20210405001914.png)



![](https://raw.githubusercontent.com/haoboliu66/PicBed/master/img/20210405001956.png)



特征: 

该指标 和 区间的大小 存在单调性

> 无需数学证明, 使用对数器验证即可



题目三

> 类似题 1000.Minimum Cost to Merge Stones - hard

摆放着n堆石子。现要将石子有次序地合并成一堆, 规定每次只能选相邻的2堆石子合并成新的一堆，

并将新的一堆石子数记为该次合并的得分

求出将n堆石子合并成一堆的最小得分（或最大得分）合并方案



## 四边形不等式技巧特征

1，两个可变参数的区间划分问题

2，每个格子有枚举行为

3，当两个可变参数固定一个，另一个参数和答案之间存在单调性关系

- 在mergeStone题目中的表现是: 
  - 固定left边界, 随着right边界的变大或变小, 合并cost随着变大或变小(因为都是正数), eg. [3...17]的合并cost 一定 < [3...18]的合并cost (right边界变大)
  - 固定right边界, 随着left边界的变大或变小, 合并cost随着变小或变大, e.g [3...17]的合并cost > [4...17]的合并cost (left边界变大)

4，而且两组单调关系是反向的：(升 升，降 降) (升 降，降 升)

- 第3条中mergeStone表现的两种单调关系是反向的

5，能否获得指导枚举优化的位置对：上+右，或者，左+下

- 左格子提供下限, 下格子提供上限 或 上格子提供下限, 右格子提供上限





## 四边形不等式技巧注意点

1，不要证明！用对数器验证！

2，枚举的时候面对最优答案相等的时候怎么处理？用对数器都试试！

3，可以把时间复杂度降低一阶

O(N^3) -> O(N^2)

O(N^2 * M) -> O(N * M) 

O(N * M^2) -> O(N * M) 

4，四边形不等式有些时候是最优解，有些时候不是

不是的原因：尝试思路，在根儿上不够好



题目四

> 410.Split Array Largest Sum - hard

给定一个整型数组 arr，数组中的每个值都为正数，表示完成一幅画作需要的时间，再给定 一个整数 num，表示画匠的数量，每个画匠只能画连在一起的画作。所有的画家 并行工作，请返回完成所有的画作需要的最少时间。

【举例】

arr=[3,1,4]，num=2。

最好的分配方式为第一个画匠画 3 和 1，所需时间为 4。第二个画匠画 4，所需时间 为 4。 因为并行工作，所以最少时间为 4。如果分配方式为第一个画匠画 3，所需时 间为 3。第二个画 匠画 1 和 4，所需的时间为 5。那么最少时间为 5，显然没有第一 种分配方式好。所以返回 4。

arr=[1,1,1,4,3]，num=3。

最好的分配方式为第一个画匠画前三个 1，所需时间为 3。第二个画匠画 4，所需时间 为 4。 第三个画匠画 3，所需时间为 3。返回 4。



画匠问题: 

思路: [0...i]个画由[j]个画匠负责, 枚举最后一个画匠负责的范围





# 四边形不等式技巧(下)

题目一:  邮局选址问题

一条直线上有居民点，邮局只能建在居民点上。给定一个有序正数数组arr，每个值表示 居民点的一维坐标，再给定一个正数 num，表示邮局数量。选择num个居民点建立num个 邮局，使所有的居民点到最近邮局的总距离最短，返回最短的总距离

【举例】

arr=[1,2,3,4,5,1000]，num=2。

第一个邮局建立在 3 位置，第二个邮局建立在 1000 位置。那么 1 位置到邮局的距离 为 2， 2 位置到邮局距离为 1，3 位置到邮局的距离为 0，4 位置到邮局的距离为 1， 5 位置到邮局的距 离为 2，1000 位置到邮局的距离为 0。这种方案下的总距离为 6， 其他任何方案的总距离都不会 比该方案的总距离更短，所以返回6



思路: [0...i]号居民点由[j]个邮局负责, 枚举最后一个邮局负责啥范围









# 状态压缩的动态规划

题目一

464.Can I Win



1 2 3 4 5    (1+5) 

1 2 3 4





题目二

TSP问题 有N个城市，任何两个城市之间的都有距离，任何一座城市到自己的距离都为0。所有点到点的距 离都存在一个N*N的二维数组matrix里，也就是整张图由邻接矩阵表示。现要求一旅行商从k城市 出发必须经过每一个城市且只在一个城市逗留一次，最后回到出发的k城，返回总距离最短的路的 距离。参数给定一个matrix，给定k。







题目三

你有无限的1 x 2的砖块, 要铺满M x N的区域, 不同的铺法有多少种?



