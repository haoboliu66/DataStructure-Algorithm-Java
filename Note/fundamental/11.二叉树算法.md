# 二叉树 基础

## 先、中、后序遍历

先序: 头左右

中序: 左头右

后序: 左右头

第一次到达一个节点就打印就是先序、第二次打印即中序、第三次即后序

## 递归遍历

递归序

## 迭代遍历

中序iterative写法需要关注

## 按层遍历

### 1.宽度优先遍历: 使用Queue

### 2.通过设置flag的方式, 来发现某一层的结束

### 3.通过一次搞定一层的方法 while + for

相关题目:

求binary tree的最大宽度

## 二叉树的序列化和反序列化

1.可以用先序或者中序或者后序或者按层遍历，来实现二叉树的序列化

2.用什么方式序列化, 就用什么方式反序列化(**其中中序无法反序列化**)

> 431.Encode N-ary Tree to Binary Tree

> 428.Serialize and Deserialize N-ary Tree

题目:

1.设计一个打印整棵树的打印函数

2.给你二叉树中的某个节点X，返回该节点的后继节点 

> 510.Inorder Successor in BST II

- 如果X有右树, 那么后继节点一定是右子树的最左节点
- 如果X没有右树, 一直往上看, 直到某个节点是它父亲的左节点 => 此时X是某个节点左树上的最右
- 如果往上找一直都没找到某个节点符合条件, 那它一定是整棵树的最右侧的叶节点, 那么它没有后继节点

3.请把一段纸条竖着放在桌子上，然后**从纸条的下边向上方对折**1次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。 如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。

给定一个输入参数N，代表纸条都从下边向上方连续对折N次。 请从上到下打印所有折痕的方向。 

例如:N=1时，打印: down N=2时，打印: down down up 





 

# 二叉树递归套路

可以解决面试中绝大多数的二叉树问题尤其是树型dp问题, 本质是利用递归遍历二叉树的便利性

递归套路步骤:

1）假设以X节点为头，假设可以向X左树和X右树要任何信息

2）在上一步的假设下，讨论以X为头节点的树，得到答案的可能性（最重要）

3）列出所有可能性后，确定到底需要向左树和右树要什么样的信息

4）把左树信息和右树信息求全集，就是任何一棵子树都需要返回的信息S

5）递归函数都返回S，每一棵子树都这么要求

6）写代码，在代码中考虑如何把左树的信息和右树信息整合出整棵树的信息

题目:

1.给定一棵二叉树的头节点head，返回这颗二叉树是不是**平衡二叉树**

```java
class Info{
  boolean isBalanced;
  int height;
}
```

2.给定一棵二叉树的头节点head，返回这颗二叉树是不是**满二叉树(Full Binary Tree)**

> n = 2 ^ h - 1

```java
class Info{
  int listNodes;
  int height;
}
```

3.给定一棵二叉树的头节点head，返回这颗二叉树是不是**搜索二叉树 - BST**

4.给定一棵二叉树的头节点head，返回这颗二叉树中是不是**完全二叉树 - CBT**

```java
class Info{
  boolean isCBT;
  boolean isFull;
  int height;
}
```

5.给定一棵二叉树的头节点head，返回这颗二叉树中**最大的二叉搜索子树的大小**

https://src.main.java.com.hliu.leetcode.com/problems/largest-bst-subtree/

```java
class Info{
  boolean isBST;
  int min;
  int max;
  int maxSize;
}
```

6.给定一棵二叉树的头节点head，返回这颗二叉树中**最大的二叉搜索子树的头节点**

7.给定一棵二叉树的头节点head，和另外两个节点a和b, 返回a和b的**最低公共祖先**

https://src.main.java.com.hliu.leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/

https://src.main.java.com.hliu.leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/

8.给定一棵二叉树的头节点head，任何两个节点之间都存在距离, 返回**整棵二叉树的最大距离**

Diameter of binary tree  https://src.main.java.com.hliu.leetcode.com/problems/diameter-of-binary-tree/

```java
class Info{
  int maxDistanceInTree;
  int height;
}
```

9.派对的最大快乐值

员工信息的定义如下:

```java
class Employee {
  public int happy; // 这名员工可以带来的快乐值
  List<Employee> subordinates; // 这名员工有哪些直接下级

}
```

 公司的每个员工都符合 Employee 类的描述。整个公司的人员结构可以看作是一棵标准的、 没有环的多叉树。树的头节点是公司唯一的老板。除老板之外的每个员工都有唯一的直接上级。 叶节点是没有任何下属的基层员工(subordinates列表为空)，除基层员工外，每个员工都有一个或多个直接下级。

这个公司现在要办party，你可以决定哪些员工来，哪些员工不来，规则：

1.如果某个员工来了，那么这个员工的所有直接下级都不能来

2.派对的整体快乐值是所有到场员工快乐值的累加

3.你的目标是让派对的整体快乐值尽量大

给定一棵多叉树的头节点boss，请返回派对的最大快乐值。


