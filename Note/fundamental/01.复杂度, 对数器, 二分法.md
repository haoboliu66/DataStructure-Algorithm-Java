# Master公式

形如:

T(N) = a * T(N/b) + O(N^d)(其中的a、b、d都是常数)

的递归函数，可以直接通过Master公式来确定时间复杂度

如果 log(b,a) < d，复杂度为O(N^d)

如果 log(b,a) > d，复杂度为O(N^log(b,a))

如果 log(b,a) == d，复杂度为O(N^d * logN)

# 二分法

1.有序数组中, 找某个数是否存在

2.有序数组中, 找 >= 某个数最左侧的位置

3.有序数组中, 找 <= 某个数最右侧的位置

4.局部最小值问题

定义局部最小:

1. [0] < [1] or
2. [N] < [N - 1] or
3. [i] < [i - 1] && [i] < [i + 1]

给定无序数组, 任意两个相邻数字不相等, 返回一个局部最小值;

根据趋势, 到一侧进行二分

相似题: 

一个数组, 小于num的都在数组左侧, 大于num的都在数组右侧, 找<num的最后一个位置, 同样可以二分

一种排他性的原则出现, 就可以二分

# 位运算

## 异或运算

异或可以看做无进位相加

1. 0 ^ n = n,   n ^ n = 0 
2. 同样一批数字进行异或运算, 结果与执行顺序无关

题目:

1.交换两个数字(不能是同一内存区域才可以用异或)

2.一种数字出现了奇数次, 其他都是偶数次

3.提取出一个int最右侧的1   ===>    01100  ---> 00100

4.两种数字出现了奇数次, 其他都是偶数次

5.统计一个int的2进制一共有多少位1

6.一个数字是不是2的power,  n == n & (~n + 1) 或 n & (n - 1) == 0

- 一个数字只有1个bit是1

7.找到离一个数字最近的2的某次方 => HashMap源码扩容操作

## bitmap

用Set判断数字是否重复, 一个int进去就占4字节, 太浪费空间

如果要记录0-31范围内的数字是否出现过, 用一个整型的32位即可, 空间是4Byte

数字范围再扩大:

要记录0-1023范围内的数字, 总共1024个数字, 需要一个长度为32的int数组

一个数字 % 64 就等于 一个数字 & 63  (仅在2的次方情况下有效)

## 位运算实现+ - x /



# 随机函数

Math.random => [0, 1) 上的数字等概率返回

[0, x)出现的概率是x, 要把这个概率调整为x^2, 如何实现?

```java
public static double xToXPower2(){
    return Math.max(Math.random(), Math.random());
}
```

只有2次都命中我要的范围, 才能保证返回结果是要求的范围
